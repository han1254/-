# **Datastructure**

![image-20210324101631396](ç¬”è®°.assets/image-20210324101631396.png)



## ch2 LinearList



### 2.1 åŸºç¡€

#### æŠ½è±¡æ•°æ®ç±»å‹å®šä¹‰ADT

ADT List {


â€‹	æ•°æ®å¯¹è±¡: D = {$a_i|a_i\in ElemSet, i = 1, 2, ..., n, n \ge 0$}

â€‹	æ•°æ®å…³ç³»: R1 = {$<a_{i - 1}, a_i>| a_{i-1}, a\in D, i = 2,...,n$}â€‹

â€‹	åŸºæœ¬æ“ä½œ:

â€‹		InitList(&L)

}










### 2.1 çº¿æ€§è¡¨

#### 2.1.1 å®šä¹‰ç»“æ„ä½“

```c
typedef struct {
    int* elem;
    int length;
    int list_size;
} SqList;
```

#### é¢˜ç›®

ã€2011ç»Ÿè€ƒçœŸé¢˜ã€‘

![image-20210327091724585](ç¬”è®°.assets/image-20210327091724585.png)

<img src="ç¬”è®°.assets/image-20210327105242904.png" alt="image-20210327105242904" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210327105308796.png" alt="image-20210327105308796" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210327105326836.png" alt="image-20210327105326836" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210327105344905.png" alt="image-20210327105344905" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210327105358832.png" alt="image-20210327105358832" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210327105421469.png" alt="image-20210327105421469" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210327105439734.png" alt="image-20210327105439734" style="zoom:67%;" />





#### ç®—æ³•æ¸…å•





### 2.2 é“¾è¡¨

#### 2.2.1 å®šä¹‰

```c
typedef struct LNode {
    int data;
    struct LNode* next;
} LNode, *LinkList;
```



**ä¸€ä¸ªé—®é¢˜ï¼š[typedef struct vs struct definitions ](https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions)**

> The common idiom is using both:

```c
typedef struct S { 
    int x; 
} S;
```

> They are different definitions. To make the discussion clearer I will split the sentence:
>
> ä»–ä»¬æ˜¯ä¸åŒçš„å®šä¹‰ã€‚ä¸ºäº†æ¸…æ¥šåœ°è®¤æ¸…é‡Œé¢çš„åŒºåˆ«ï¼Œæˆ‘æŠŠä¸Šé¢çš„å®šä¹‰åˆ†å¼€æ¥å†™ï¼š

```c
struct S { 
    int x; 
};

typedef struct S S;
```

> In the first line you are defining the identifier `S` within the struct name space (not in the C++ sense). You can use it and define variables or function arguments of the newly defined type by defining the type of the argument as `struct S`:
>
> ç¬¬ä¸€è¡Œä½ åœ¨ç»“æ„ä½“å‘½åç©ºé—´ä¸­å®šä¹‰äº†ä¸€ä¸ªæ ‡è¯†ç¬¦Sï¼Œä½ å¯ä»¥ä½¿ç”¨`struct S`è¿™ç§æ–¹å¼å®šä¹‰å˜é‡æˆ–è€…å‡½æ•°å‚æ•°ã€‚

```c
void f( struct S argument ); // struct is required here
```

> The second line adds a type alias `S` in the global name space and thus allows you to just write:
>
> `typedef`åˆ™å®šä¹‰äº†ä¸€ä¸ªæ–°çš„ç±»å‹`S`ï¼Œè€Œ`S`æŒ‡çš„æ˜¯`struct S`ï¼Œå› æ­¤ä½ å¯ä»¥å‘ä¸‹é¢è¿™æ ·å®šä¹‰å˜é‡æˆ–è€…å‚æ•°ï¼š

```c
void f( S argument ); // struct keyword no longer needed
```

> Note that since both identifier name spaces are different, defining `S` both in the structs and global spaces is not an error, as it is not redefining the same identifier, but rather creating a different identifier in a different place.
>
> To make the difference clearer:

```c
typedef struct S { 
    int x; 
} T;

void S() { } // correct

//void T() {} // error: symbol T already defined as an alias to 'struct S'
```

> You can define a function with the same name of the struct as the identifiers are kept in different spaces, but you cannot define a function with the same name as a `typedef` as those identifiers collide.
>
> In C++, it is slightly different as the rules to locate a symbol have changed subtly. C++ still keeps the two different identifier spaces, but unlike in C, when you only define the symbol within the class identifier space, you are not required to provide the struct/class keyword:

```c
 // C++
struct S { 
    int x; 
}; // S defined as a class

void f( S a ); // correct: struct is optional
```

> What changes are the search rules, not where the identifiers are defined. The compiler will search the global identifier table and after `S` has not been found it will search for `S` within the class identifiers.
>
> The code presented before behaves in the same way:

```c
typedef struct S { 
    int x; 
} T;

void S() {} // correct [*]

//void T() {} // error: symbol T already defined as an alias to 'struct S'
```

> After the definition of the `S` function in the second line, the struct `S` cannot be resolved automatically by the compiler, and to create an object or define an argument of that type you must fall back to including the `struct` keyword:

```c
// previous code here...
int main() {
    S(); 
    struct S s;
}
```

**å…³äºtypedefå®šä¹‰æŒ‡é’ˆç±»å‹ï¼š[typedef structå’ŒæŒ‡é’ˆ](https://blog.csdn.net/u013814701/article/details/52996544)**



ä¾‹å¦‚:

```c
typedef struct LNode {
    int data;
    struct LNode *next;
} ListNode, *LinkList;
```

é‚£ä¹ˆåœ¨ä»¥åçš„ä½¿ç”¨ä¸­ï¼Œæˆ‘å¦‚æœæƒ³ä½¿ç”¨`LNode`æ¥å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œæˆ‘å¿…é¡»ä½¿ç”¨`struct LNode value`

å¦‚æœç”¨`ListNode`æ¥å®šä¹‰ï¼Œé‚£ä¹ˆåªéœ€è¦`ListNode value`ï¼Œå¦‚æœä½¿ç”¨`LinkList`æ¥å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œæ•ˆæœè·Ÿ`ListNode* value`æ˜¯ä¸€æ ·çš„ã€‚

#### 2.2.2 å„ç§ç®—æ³•

```c
/**
 * al-2.8
 *
 * @param L
 * @param i
 * @param e
 * @return
 */
int GetElem_L(LinkList L, int i, int* e)
{
    LinkList p = L->next;
    int j = 0;
    while(p != NULL && j < i)
    {
        j++;
        p = p->next;
    }
    if(p == NULL) return ERROR;
    *e = p->data;
    return OK;
}

/**
 * al-2.9
 * @param L
 * @param i
 * @param e
 * @return
 */
int ListInsert_L(LinkList L, int i, int e)
{
    LinkList p = L;
    int j = 0;
    while(p != NULL && j < i)
    {
        p = p->next;
        j++;
    }
    if (p == NULL) return ERROR;
    LinkList node = (LinkList)malloc(sizeof(ListNode));
    node->data = e;
    node->next = p->next;
    p->next = node;
    return OK;
}

/**
 * al-2.10
 * @param L
 * @param i
 * @param e
 * @return
 */
int ListDelete_L(LinkList L, int i, int* e)
{
    LinkList p = L;
    int j = 0;
    while(p != NULL && j < i)
    {
        p = p->next;
        j++;
    }
    if(p == NULL) return ERROR;
    *e = p->next->data;
    p->next = p->next->next;
    return OK;
}

void CreateList_L_HeadInsert(LinkList* L, int n)
{
    //create a head node
    *L = (LinkList)malloc(sizeof(ListNode));
    (*L)->next = NULL;
    for (int i = 0; i < n; ++i)
    {
        LinkList node = (LinkList)malloc(sizeof(ListNode));
        node->data = i + 1;
        node->next = (*L)->next;
        (*L)->next = node;
    }
}
/**
 * al-2.11-2
 * @param L
 * @param n
 */
void CreateList_L_TailInsert(LinkList* L, int n)
{
    *L = (LinkList)malloc(sizeof(ListNode));
    (*L)->next = NULL;
    LinkList p = *L;
    for (int i = 0; i < n; ++i)
    {
        LinkList node = (LinkList)malloc(sizeof(ListNode));
        node->data = i + 1;
        node->next = p->next;
        p->next = node;
        p = p->next;
    }
}
/**
 * al-2.12
 * @param La
 * @param Lb
 * @param Lc
 */
void MergeList_L(LinkList La, LinkList Lb, LinkList* Lc)
{
    LinkList pa = La->next;
    LinkList pb = Lb->next;

    *Lc = La;
    LinkList pc = *Lc;
    while(pa != NULL && pb != NULL)
    {
        if(pa->data <= pb->data) {
            pc->next = pa;
            pa = pa->next;
        } else {
            pc->next = pb;
            pb = pb->next;
        }
        pc = pc->next;
    }
    if(pa != NULL) pc->next = pa;
    else pc->next = pb;
}
```



#### 2.2.x é—®é¢˜æ€»ç»“

##### **å€¼ä¼ é€’**çš„é—®é¢˜

```c
void CreateList_L_HeadInsert(LinkList L, int n)
{
    //create a head node
    L = (LinkList)malloc(sizeof(ListNode));
    L->next = NULL;
    for (int i = 0; i < n; ++i)
    {
        LinkList node = (LinkList)malloc(sizeof(ListNode));
        node->data = i + 1;//ä¹¦ä¸Šæ˜¯è®©è¾“å…¥çš„ï¼Œæˆ‘å«Œéº»çƒ¦ï¼Œå…ˆè¿™æ ·ç›´æ¥èµ‹å€¼äº†
        node->next = L->next;
        L->next = node;
    }
}
```

![image-20210323223916044](ç¬”è®°.assets/image-20210323223916044.png)

å½“æˆ‘ä»¬è°ƒç”¨è¿™ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œä¼ å…¥çš„æŒ‡é’ˆä¸º`l2(LinkList l2 <=> ListNode* l2)`ï¼Œ`l2`å­˜å‚¨çš„åœ°å€ä¸º`0x555674e1f630`

![image-20210323225350249](ç¬”è®°.assets/image-20210323225350249.png)

å½“æˆ‘ä»¬è·³å…¥å‡½æ•°`CreateList_L_HeadInsert`çš„æ—¶å€™ï¼Œä¼ å…¥çš„`L`çš„å€¼ä¾æ—§æ˜¯`0x555674e1f630`ï¼›ä½†æ˜¯å½“æˆ‘ä»¬æ‰§è¡Œäº†`malloc`å‡½æ•°åï¼Œå‡½æ•°ä½œç”¨åŸŸå†…çš„`L`çš„å€¼å·²ç»å‘ç”Ÿäº†å˜åŒ–ï¼Œå¯ä»¥è¯´**Lå·²ç»ä¸æ˜¯æˆ‘ä»¬ä¼ å…¥çš„é‚£ä¸ªæŒ‡é’ˆäº†**ã€‚

![image-20210323225418745](ç¬”è®°.assets/image-20210323225418745.png)

é‚£ä¹ˆæˆ‘ä»¬æ¥ä¸‹æ¥çš„æ‰€æœ‰æ“ä½œï¼Œéƒ½æ˜¯é’ˆå¯¹æŒ‡é’ˆåœ°å€ä¸º`0x55d96508e710`ï¼Œå¤§å°ä¸º`sizeof(ListNode)`çš„è¿™ä¸ªæ•°æ®æ®µè¿›è¡Œçš„æ“ä½œäº†ï¼Œæ‰€ä»¥è‡ªç„¶ä¸ä¼šåæ˜ åˆ°mainé‡Œé¢çš„`l2`

æ‰€ä»¥æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆæ˜¯**äºŒé‡æŒ‡é’ˆ**

```c
void CreateList_L_HeadInsert(LinkList* L, int n)
{
    //create a head node
    *L = (LinkList)malloc(sizeof(ListNode));//ğŸ‘ˆé‡ç‚¹åœ¨è¿™é‡Œ
    (*L)->next = NULL;
    for (int i = 0; i < n; ++i)
    {
        LinkList node = (LinkList)malloc(sizeof(ListNode));
        node->data = i + 1;//ä¹¦ä¸Šæ˜¯è®©è¾“å…¥çš„ï¼Œæˆ‘å«Œéº»çƒ¦ï¼Œå…ˆè¿™æ ·ç›´æ¥èµ‹å€¼äº†
        node->next = (*L)->next;
        (*L)->next = node;
    }
}
```

ï¼ˆæ˜¨å¤©å¤ªæ‡’äº†ï¼Œæ²¡æœ‰å†™å®Œï¼Œ æ‰€ä»¥ä»Šè¡¥ä¸Šçš„æ—¶å€™åœ°å€éƒ½å˜äº†ï¼Œä¸è¿‡é—®é¢˜ä¸å¤§ï¼‰

![image-20210324104359419](ç¬”è®°.assets/image-20210324104359419.png)

`*L = (LinkList)malloc(sizeof(ListNode));//ğŸ‘ˆé‡ç‚¹åœ¨è¿™é‡Œ`

![image-20210324104516242](ç¬”è®°.assets/image-20210324104516242.png)

ç»è¿‡äº†mallocåˆ†é…åï¼ŒæŒ‡é’ˆ`L`æŒ‡å‘çš„ä½ç½®å†…çš„æ•°æ®è¢«é‡æ–°èµ‹å€¼ï¼Œç”±åŸæ¥çš„`0x55bc3008b60`å˜æˆäº†ä¸‹é¢çš„`0x55bc302d2710`

![image-20210324104607511](ç¬”è®°.assets/image-20210324104607511.png)

å½“å‡½æ•°æ‰§è¡Œå®Œè·³å›mainå‡½æ•°çš„æ—¶å€™ï¼Œæˆ‘ä»¬çœ‹åˆ°`l2`çš„å€¼çœŸçš„è·Ÿç€æ”¹å˜äº†ã€‚

![image-20210324104653895](ç¬”è®°.assets/image-20210324104653895.png)

æˆ‘ä»¬å¯ä»¥ç”¨å›¾ç‰‡æ›´å½¢è±¡åœ°åæ˜ ä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹

åˆšå¼€å§‹çš„æ—¶å€™

<img src="ç¬”è®°.assets/image-20210324111345948.png" alt="image-20210324111345948" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210324111700034.png" alt="image-20210324111700034" style="zoom:67%;" />



å½“æˆ‘ä»¬è°ƒç”¨`CreateList_L_HeadInsert(LinkList* L, int n)`æ—¶ï¼Œä¼ å…¥çš„æ˜¯`l2`çš„åœ°å€`0x7ffc1eb84c80`

`*L = (LinkList)malloc(sizeof(ListNode));`ä¸­ï¼Œ`*L`å¯ä»¥è®¤ä¸ºæ˜¯é€šè¿‡Lè¿™ä¸ªåœ°å€ï¼Œæ‰¾åˆ°**Lè¿™ä¸ªåœ°å€å¯¹åº”çš„ä½ç½®**

è€Œèµ‹å€¼æ“ä½œï¼Œåˆ™æ˜¯å°†`(LinkList)malloc(sizeof(ListNode))`åˆ†é…çš„å†…å­˜ç©ºé—´çš„**èµ·å§‹åœ°å€è¿™ä¸ªå€¼**æ”¾åˆ°äº†è¿™ä¸ªä½ç½®

<img src="ç¬”è®°.assets/image-20210324111407977.png" alt="image-20210324111407977" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210324111734687.png" alt="image-20210324111734687" style="zoom:67%;" />

<img src="ç¬”è®°.assets/image-20210324111830703.png" alt="image-20210324111830703" style="zoom:67%;" />

##### sizeofé—®é¢˜

```c
int getLen(int a[])
{
    return sizeof(a) / sizeof(int);
}

int main() {
//    test_se2_del_min();
    int a[] = {1, 3, 6, 9, 10, 1, 3, 1, 5, 9};
    printf("len = %d\n",getLen(a));
    printf("len = %d\n", sizeof(a) / sizeof(int));
}
```

ç»“æœä¸ºï¼š

```
/home/han1254/Documents/Datastructure/CSKAOYAN/cmake-build-debug/CSKAOYAN
len = 2
len = 10

Process finished with exit code 0
```

> cè¯­è¨€ä¸­ï¼Œå®šä¹‰æ•°ç»„åå¯ä»¥ç”¨sizeofå‘½ä»¤è·å¾—æ•°ç»„çš„é•¿åº¦ï¼ˆå¯å®¹çº³å…ƒç´ ä¸ªæ•°ï¼‰ã€‚
> ä¾‹å¦‚ï¼š
>
> ```c
> int data[4];
> int length;
> length=sizeof(data)/sizeof(data[0]); //æ•°ç»„å å†…å­˜æ€»ç©ºé—´ï¼Œé™¤ä»¥å•ä¸ªå…ƒç´ å å†…å­˜ç©ºé—´å¤§å°
> printf("length of data[4]=%d", length ); //è¾“å‡ºlength of data[4]=4
> ```
>
> ä½†æ˜¯ï¼Œé€šè¿‡ä¼ é€’æ•°ç»„åå‚æ•°åˆ°å­å‡½æ•°ä¸­ï¼Œä»¥è·å¾—æ•°ç»„é•¿åº¦æ˜¯ä¸å¯è¡Œçš„ã€‚
> ä¾‹å¦‚ï¼š
>
> ```c
> int getLength(int[] a)
> { 
>     int length;length=sizeof(a)/sizeof(a[0]); //è¿™æ ·æ˜¯é”™è¯¯çš„ï¼Œå¾—åˆ°çš„ç»“æœæ°¸è¿œæ˜¯1
> 	return length;
> }
> ```
>
> å› ä¸ºï¼Œaæ˜¯å‡½æ•°å‚æ•°ï¼Œåˆ°äº†æœ¬å‡½æ•°ä¸­ï¼Œaåªæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ˆåœ°å€ï¼Œç³»ç»Ÿåœ¨æœ¬å‡½æ•°è¿è¡Œæ—¶ï¼Œæ˜¯ä¸çŸ¥é“aæ‰€è¡¨ç¤ºçš„åœ°å€æœ‰å¤šå¤§çš„æ•°æ®å­˜å‚¨ç©ºé—´ï¼Œè¿™é‡Œåªæ˜¯å‘Šè¯‰å‡½æ•°ï¼šä¸€ä¸ªæ•°æ®å­˜å‚¨ç©ºé—´é¦–åœ°å€ï¼‰ï¼Œæ‰€ä»¥ï¼Œsizoef(a)çš„ç»“æœæ˜¯æŒ‡é’ˆå˜é‡aå å†…å­˜çš„å¤§å°ï¼Œä¸€èˆ¬åœ¨32ä½æœºä¸Šæ˜¯4ä¸ªå­—èŠ‚ã€‚a[0]æ˜¯intç±»å‹ï¼Œsizeof(a[0])ä¹Ÿæ˜¯4ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥ï¼Œç»“æœæ°¸è¿œæ˜¯1ã€‚3ã€å› æ­¤ï¼Œè·å¾—æ•°ç»„é•¿åº¦ï¼Œåªèƒ½åœ¨æ•°ç»„å®šä¹‰æ‰€åœ¨çš„ä»£ç åŒºä¸­ï¼Œé‡‡ç”¨ä»¥ä¸Šæ–¹æ³•ï¼Œæ‰å¯ä»¥è¾¾åˆ°æ•ˆæœã€‚
>
> â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
> ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºCSDNåšä¸»ã€ŒYanWenCheng_ã€çš„åŸåˆ›æ–‡ç« ï¼Œéµå¾ªCC 4.0 BY-SAç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥åŠæœ¬å£°æ˜ã€‚
> åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/YanWenCheng_/article/details/95358597



## ch3 Stack and Queue



### Stack

#### æ ˆçš„é¡ºåºå­˜å‚¨ç»“æ„

```c
//SqStack.h
#ifndef SQSTACK_H
#define SQSTACK_H
#define MaxSize 50
typedef struct {
        int* data;
        int top;
} SqStack;

#endif
```

```c
//SqStackImpl.h
#ifndef SQSTACK_IMPL_H
#define SQSTACK_IMPL_H
#include "SqStack.h"
#include "stdlib.h"
void PrintStack(SqStack S)
{
	for(int i = 0; i <= S.top; i++)
	{
		printf("%d\n", S.data[i]);
	}
}
void InitStack(SqStack* S)
{
	S->data = (int*)malloc(MaxSize * sizeof(int));
	S->top = -1;
}

int StackEmpty(SqStack S)
{
	if(S.top == -1) return 0;
	return 1;
}

int Push(SqStack* S, int x)
{
	if(S->top == MaxSize - 1)
		return 0;
	S->data[++S->top] = x;
	return 1;
}

int Pop(SqStack* S, int* e)
{
	if(S->top == -1) return 0;
	*e = S->data[S->top--];
	return 1;
}

int GetTOp(SqStack S, int* e)
{
	if(S.top == -1) return 0;
	*e = S.data[S.top];
	return 1;
}
#endif
```

```c
//StackMain.c
#include <stdio.h>
#include "SqStackImpl.h"

int main()
{
	SqStack s;
	InitStack(&s);
	Push(&s, 1);
	Push(&s, 2);
	Push(&s, 3);
	PrintStack(s);
}
```

#### æ ˆçš„é“¾å¼å­˜å‚¨ç»“æ„



### Queue



### ç›¸å…³é—®é¢˜

#### å…¥æ ˆé¡ºåºå·²çŸ¥ï¼Œå‡ºæ ˆåºåˆ—èƒ½æœ‰å¤šå°‘ç§ï¼Ÿ

[5. å¡ç‰¹å…°æ•°ï¼ˆCatalanï¼‰å…¬å¼ã€è¯æ˜ã€ä»£ç ã€å…¸ä¾‹.](https://blog.csdn.net/Sherry_Yue/article/details/88364746)

Catalanå…¬å¼çš„é€šé¡¹å…¬å¼

**$$C_n = \frac{1}{(n + 1)}C_{2n}^n = \frac{(2n)!}{(n + 1)n!(2n - n)!} = \frac{(2n)!}{(n + 1)!n!}$$**



#### ç»“æ„ä½“çš„åˆå§‹åŒ–é—®é¢˜



#### æŠŠé€’å½’ç”¨æ ˆè¡¨ç¤º





## ch4 String

### KMPç®—æ³•æ€è€ƒ

KMPç®—æ³•ï¼Œç”¨ä¸€å¥è¯å½¢å®¹å°±æ˜¯ï¼š**ä¸»ä¸²ä¸æ¨¡å¼ä¸²é€ä¸€å¯¹æ¯”ï¼Œå‘ç°ä¸åŒ¹é…ï¼Œåˆ™ç§»åŠ¨æ¨¡å¼ä¸²æŒ‡é’ˆï¼Œç”¨æœ€é•¿å‰ç¼€çš„åä¸€ä½ä¸ä¸»ä¸²æŒ‡é’ˆå¯¹é½ã€‚**

é¦–å…ˆæˆ‘ä»¬è¦æ˜ç¡®ä¸€ä¸‹å‰ç¼€å’Œåç¼€çš„é—®é¢˜ã€‚



å‰ç¼€æŒ‡ä¸²é™¤äº†æœ€åä¸€ä¸ªå­—ç¬¦ä¹‹å¤–ï¼Œå­—ç¬¦ä¸²æ‰€æœ‰å¤´éƒ¨å­ä¸²ï¼›åç¼€æŒ‡çš„æ˜¯é™¤äº†ç¬¬ä¸€ä¸ªå­—ç¬¦å¤–ï¼Œå­—ç¬¦ä¸²çš„æ‰€æœ‰å°¾éƒ¨å­ä¸²ã€‚

æ¯”å¦‚ababcdï¼Œå‰ç¼€ä¸º{a, ab, aba, abab, ababc}ï¼Œåç¼€ä¸º{d, cd, bcd, abcd, babcd}

![image-20210426225633581](ç¬”è®°.assets/image-20210426225633581.png)

å¦‚ä¸Šå›¾æ˜¯ä¸€ä¸ªæ¨¡å¼ä¸²ï¼Œåºåˆ—ä¸€å’Œåºåˆ—äºŒæ˜¯åœ¨ä½ç½®iä¹‹å‰çš„å­—ç¬¦ä¸²ä¸­ï¼Œ**ç›¸ç­‰çš„ä¸”æœ€é•¿**çš„å‰åç¼€ã€‚

ä½ å¯ä»¥ç±»æ¯”ä¸Šé¢çš„ababcdï¼Œåºåˆ—<font color = red>ab</font><font color = green>ab</font>å°±ç›¸å½“äºåœ¨ä½ç½®iä¹‹å‰çš„åºåˆ—ï¼Œè€Œ<font color = red>ab</font>å’Œ<font color = green>ab</font>åˆ™æ˜¯ç›¸åŒçš„å‰åç¼€ã€‚

æˆ‘ä»¬æ‰¾å‰åç¼€çš„ç›®çš„å°±åƒä¸‹é¢è¿™æ ·ï¼š

![image-20210426224708765](ç¬”è®°.assets/image-20210426224708765.png)

æ¯”å¦‚æˆ‘æœ‰ä¸€ä¸ªä¸²Sï¼Œå’Œä¸€ä¸ªæ¨¡å¼ä¸²Tï¼Œæˆ‘ä»Sçš„posä½ç½®ä»¥åŠTçš„1ä½ç½®å¼€å§‹ï¼ˆæ•°æ®ç»“æ„ä¸­å¯¹äºä¸²ï¼Œå¤§éƒ½ä»1å¼€å§‹ï¼Œ0ä½ç½®å­˜å‚¨ä¸²çš„é•¿åº¦ï¼‰æ¯”è¾ƒï¼Œå¦‚æœå‡ºç°

S[i] != T[j]ï¼Œæˆ‘ä¸æƒ³ç›´æ¥åƒæš´åŠ›è§£æ³•é‚£æ ·ï¼Œ**æŠŠä¸»ä¸²æŒ‡é’ˆè·³å›åˆ°èµ·å§‹ä½ç½®çš„ä¸‹ä¸€ä½ï¼ŒåŒæ—¶æŠŠæ¨¡å¼ä¸²çš„æŒ‡é’ˆè·³å›ä½ç½®1**ï¼›æˆ‘åœ¨æƒ³ï¼Œè™½ç„¶ä»–ä»¬åœ¨S[i]å’ŒT[j]å¤„äº§ç”Ÿäº†ä¸åŒ¹é…ï¼Œä½†æ˜¯ä»–ä»¬å‰é¢å¯æ˜¯åŒ¹é…çš„ã€‚

æš´åŠ›è§£æ³•çš„ä»£ç æ˜¯è¿™æ ·çš„

```c
int Index_Slow(const SString S, const SString T, int pos) {
    int i = pos;
    int j = 1;
    while (i <= S[0] && j <= T[0]) {
        if (S[i] == T[j]) {
            i++;
            j++;
        } else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T[0]) return i - T[0];//æ­¤æ—¶iä¹Ÿåˆ°äº†åŒ¹é…çš„æœ€åä¸€ä½çš„åä¸€ä½ï¼Œæ‰€ä»¥ç›´æ¥i-T[0]ï¼Œä¸ç”¨åŠ ä¸€
    return 0;
}
```

æˆ‘ä»¬çœ‹åˆ°ï¼Œåœ¨elseé‡Œé¢ï¼Œå¦‚æœå‡ºç°ä¸åŒ¹é…çš„æƒ…å†µï¼Œä¸»ä¸²æŒ‡é’ˆæŒ‡å‘åŸæ¥çš„èµ·å§‹ç‚¹çš„ä¸‹ä¸€ä½ï¼Œè€Œæ¨¡å¼ä¸²æŒ‡é’ˆåˆ™æŒ‡å‘äº†ç¬¬ä¸€ä½ã€‚

è€ŒKMPç®—æ³•åˆ™æ˜¯è®¤ä¸ºæˆ‘ä¸éœ€è¦å›æº¯ä¸»ä¸²æŒ‡é’ˆï¼Œ

## Tree
```
/home/han1254/Documents/PGEE/clion_datastructure/cmake-build-debug/tree_main
input root
-
Now it's 2th level, you have to enter 2 nodes(enter '#' as a symbol of null)
+/
end the input?(y or n)
n
Now it's 3th level, you have to enter 4 nodes(enter '#' as a symbol of null)
a*ef
end the input?(y or n)
n
Now it's 4th level, you have to enter 8 nodes(enter '#' as a symbol of null)
##b-####
end the input?(y or n)
n
Now it's 5th level, you have to enter 16 nodes(enter '#' as a symbol of null)
######cd########
end the input?(y or n)
y
a + b * c - d - e / f 
- + a * b - c d / e f 
a b c d - * + e f / - 
```

### æ•°æ®è½¬æ¢ï¼Œå­ç»“æ„ä½“
[Cè¯­è¨€ç»“æ„ä½“çš„â€œç»§æ‰¿â€](https://www.cnblogs.com/qiumingcheng/p/11229086.html)