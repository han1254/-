## 1. 从上到下打印二叉树

不分层：

```java
public int[] levelOrder(TreeNode root) {
        if(root == null) {
            return new int[0];
        }
        List<Integer> resList = new ArrayList<>();
	 	Queue<TreeNode> que = new LinkedList<>();
        que.add(root);
        while(!que.isEmpty()) {
            TreeNode tempNode = que.remove();
            resList.add(tempNode.val);
            if(tempNode.left != null) {
                que.add(tempNode.left);
            }

            if(tempNode.right != null) {
                que.add(tempNode.right);
            }

        }
        int[] res = new int[resList.size()];
        for(int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }
```

分层

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) {
            return new ArrayList<>();
        }
        List<List<Integer>> resList = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            List<Integer> tempList = new ArrayList<>();
            for(int i = queue.size(); i > 0; i--) {
                TreeNode tempNode = queue.remove();
                tempList.add(tempNode.val);
                if(tempNode.left != null) {
                    queue.add(tempNode.left);
                }
                if(tempNode.right != null) {
                    queue.add(tempNode.right);
                }
            }
            resList.add(tempList);
        }
        return resList;
    }
```



## 2. 搜索

### 2.1 二分搜索

```java
int binarySearch(int[] arr, int target) {
    int i = 0, j = arr.length - 1;
    int m;
    while(i <= j) {
        m = (i + j) / 2;
        if(arr[m] == target) {
            return m;
        } else if(arr[m] < target) {
            i = m + 1;
        } else {
            j = m - 1;
        }
    }
    return -1;
}
```

？为什么是`i <= j`而不是`i < j`

如果`while`中是`i < j`的话，也就是说一旦`i == j`，循环就需要退出。但是，如果是这种情况

>因为假设在[1,3]中寻找2，low和high会重合，但是还不确定能否找到目标值，循环不应该停止。
>
>...
>
>对于二分搜索来说，如果找不到，每次都会移动左边界或右边界，每次边界至少会移动1个位置，且两个边界每次只有一个移动，而且移动时不会超过另一侧的边界，那么两边界最终一定会相遇。每次移动时，目标都处于两边界之间(含)，所以最后两边界重合时，目标只可能是两边界重合的位置或不存在。所以即使两边界重合，还要做一次判断才可以。所以循环条件加入了等于的情况，其实如果不加等于，后续做一次判断，也是完全可以的。
>
>
>
>作者：熊白白
>链接：https://www.jianshu.com/p/5f80e5f4bfb2
>来源：简书
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



例一：

>[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

> 难度简单94

> 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

+ 错误一

```java
class Solution {
    public int missingNumber(int[] nums) {
        int i = 0, j = nums.length - 1;
        int m;
        while(i <= j) {
            m = (i + j) / 2;
            if(nums[m] > m) {
                j = m;
            } else {
                i = m + 1;
            }
        }
        return j;
    }
}
```

错误样例：

![image-20210114215424771](算法笔记.assets/image-20210114215424771.png)

最后会一直停留在位置2上。

+ 正确结果

```java
class Solution {
    public int missingNumber(int[] nums) {
        int i = 0, j = nums.length - 1;
        int m;
        while(i <= j) {
            m = (i + j) / 2;
            if(nums[m] > m) {
                j = m - 1;
            } else {
                i = m + 1;
            }
        }
        return i;
    }
}
```

